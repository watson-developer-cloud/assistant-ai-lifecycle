{
  "openapi": "3.0.1",
  "info": {
    "title": "IBM Watson Discovery query endpoint",
    "description": "IBM Watson Discovery simplified API spec for querying.  You can also download the full spec for the entire service by going to https://cloud.ibm.com/apidocs/discovery-data and clicking on the menu in the upper right.",
    "version": "1.0"
  },
  "servers": [
		{
			"url": "https://api.{subdomain}.discovery.watson.cloud.ibm.com",
			"description": "Production servers available to customers",
			"variables": {
				"subdomain": {
					"default": "us-south",
					"description": "The region where your instance is located"
				}
			}
		},
    {
      "url": "https://api.{subdomain}.discovery.test.watson.cloud.ibm.com",
      "description": "Test servers for internal IBM use only",
      "variables": {
        "subdomain": {
          "default": "us-south",
          "description": "The region where your instance is located"
        }
      }
    }
	],
  "security": [
    {
      "basicAuth": [
      ]
    }
  ],
  "externalDocs": {
    "description": "For more information about this service, see docs.",
    "url": "https://cloud.ibm.com/docs/discovery-data",
    "x-release-notes": "https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-release-notes"
  },
  "paths": {
    "/v2/projects/{project_id}/query": {
      "post": {
        "operationId": "query",
        "summary": "Query a project",
        "description": "Search your data by submitting queries that are written in natural language or formatted in the Discovery Query Language. For more information, see the [Discovery documentation](https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-query-concepts). The default query parameters differ by project type. For more information about the project default settings, see the [Discovery documentation](https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-query-defaults). See [the Projects API documentation](#create-project) for details about how to set custom default query settings. \n\nThe length of the UTF-8 encoding of the POST body cannot exceed 10,000 bytes, which is roughly equivalent to 10,000 characters in English.",
        "tags": [
          "Queries"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/projectIdParam"
          },
          {
            "$ref": "#/components/parameters/versionParam"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/QueryLarge"
        },
        "responses": {
          "200": {
            "description": "Query executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request.\n\n* Project has no collections.\n\n* A list of document ids is required in **similar.document_ids** when **similar.enabled** is `true`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "x-sdk-operations": {
          "request-examples": {
            "curl": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "curl -X POST {auth} \\\n",
                      "--header \"Content-Type: application/json\" \\\n",
                      "--data \"{ \\\n",
                      "  \\\"collection_ids\\\": [  \\\n",
                      "    \\\"{collection_id_1}\\\", \\\n",
                      "    \\\"{collection_id_2}\\\" \\\n",
                      "  ], \\\n",
                      "  \\\"query\\\": \\\"text:IBM\\\" \\\n",
                      "}\" \\\n",
                      "\"{url}/v2/projects/{project_id}/query?version=2020-08-30\""
                    ]
                  }
                ]
              }
            ],
            "java": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "CloudPakForDataAuthenticator authenticator = new CloudPakForDataAuthenticator(\"https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize\", \"{username}\", \"{password}\");\n",
                      "Discovery discovery = new Discovery(\"2020-08-30\", authenticator);\n",
                      "discovery.setServiceUrl(\"https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api\");\n",
                      "\n",
                      "QueryOptions options = new QueryOptions.Builder()\n",
                      "  .projectId(\"{project_id}\")\n",
                      "  .query(\"{field}:{value}\")\n",
                      "  .build();\n",
                      "\n",
                      "QueryResponse response = discovery.query(options).execute().getResult();\n",
                      "\n",
                      "System.out.println(response);"
                    ]
                  }
                ]
              }
            ],
            "node": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "const DiscoveryV2 = require('ibm-watson/discovery/v2');\n",
                      "const { CloudPakForDataAuthenticator } = require('ibm-watson/auth');\n",
                      "\n",
                      "const discovery = new DiscoveryV2({\n",
                      "  authenticator: new CloudPakForDataAuthenticator({\n",
                      "    url: 'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "    username: '{username}',\n",
                      "    password: '{password}',\n",
                      "  }),\n",
                      "  version: '2020-08-30',\n",
                      "  serviceUrl: 'https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api',\n",
                      "});\n",
                      "\n",
                      "const params = {\n",
                      "  projectId: '{projectId}',\n",
                      "  query: '{field}:{value}',\n",
                      "};\n",
                      "\n",
                      "discovery.query(params)\n",
                      "  .then(response => {\n",
                      "    console.log(JSON.stringify(response.result, null, 2));\n",
                      "  })\n",
                      "  .catch(err => {\n",
                      "    console.log('error:', err);\n",
                      "  });\n",
                      ""
                    ]
                  }
                ]
              }
            ],
            "python": [
              {
                "name": "Example request",
                "example": [
                  {
                    "type": "code",
                    "source": [
                      "import json\n",
                      "from ibm_watson import DiscoveryV2\n",
                      "from ibm_cloud_sdk_core.authenticators import CloudPakForDataAuthenticator\n",
                      "\n",
                      "authenticator = CloudPakForDataAuthenticator(\n",
                      "                              '{username}',\n",
                      "                              '{password}',\n",
                      "                              'https://{cpd_cluster_host}{:port}/icp4d-api/v1/authorize',\n",
                      "                               disable_ssl_verification=True)\n",
                      "discovery = DiscoveryV2(\n",
                      "  version='2020-08-30',\n",
                      "  authenticator=authenticator\n",
                      ")\n",
                      "discovery.set_service_url('{https://{cpd_cluster_host}{:port}/discovery/{release}/instances/{instance_id}/api}')\n",
                      "\n",
                      "response = discovery.query(\n",
                      "  project_id='{project_id}',\n",
                      "  query='{field:value}'\n",
                      ").get_result()\n",
                      "\n",
                      "print(json.dumps(response, indent=2))\n",
                      ""
                    ]
                  }
                ]
              }
            ]
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    },
    "parameters": {
      "versionParam": {
        "name": "version",
        "in": "query",
        "description": "Release date of the version of the API you want to use. Specify dates in YYYY-MM-DD format. The current version is `2020-08-30`.",
        "required": true,
        "schema": {
          "type": "string"
        },
        "x-sdk-global-param": true
      },
      "projectIdParam": {
        "name": "project_id",
        "in": "path",
        "description": "The ID of the project. This information can be found from the *Integrate and Deploy* page in Discovery.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "collectionIdsParam": {
        "name": "collection_ids",
        "in": "query",
        "description": "Comma separated list of the collection IDs. If this parameter is not specified, all collections in the project are used.",
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "collectionIdParam": {
        "name": "collection_id",
        "in": "path",
        "description": "The ID of the collection.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "documentIdParam": {
        "name": "document_id",
        "in": "path",
        "description": "The ID of the document.",
        "required": true,
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255,
          "pattern": "^[a-zA-Z0-9_-]*$"
        }
      },
      "acFieldParam": {
        "name": "field",
        "in": "query",
        "description": "The field in the result documents that autocompletion suggestions are identified from.",
        "schema": {
          "type": "string"
        }
      },
      "acPrefixParam": {
        "name": "prefix",
        "in": "query",
        "description": "The prefix to use for autocompletion. For example, the prefix `Ho` could autocomplete to `hot`, `housing`, or `how`.",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "acCountParam": {
        "name": "count",
        "in": "query",
        "description": "The number of autocompletion suggestions to return.",
        "schema": {
          "type": "integer",
          "default": 5
        }
      },
      "filterParam": {
        "name": "filter",
        "in": "query",
        "description": "Searches for documents that match the Discovery Query Language criteria that is specified as input. Filter calls are cached and are faster than query calls because the results are not ordered by relevance. When used with the `aggregation`, `query`, or `natural_language_query` parameters, the `filter` parameter runs first. This parameter is useful for limiting results to those that contain specific metadata values.",
        "schema": {
          "type": "string"
        }
      },
      "queryParam": {
        "name": "query",
        "in": "query",
        "description": "A query search that is written in the Discovery Query Language and returns all matching documents in your data set with full enrichments and full text, and with the most relevant documents listed first.",
        "schema": {
          "type": "string"
        }
      },
      "nlqParam": {
        "name": "natural_language_query",
        "in": "query",
        "description": "A natural language query that returns relevant documents by using training data and natural language understanding.",
        "schema": {
          "type": "string",
          "minLength": 1,
          "maxLength": 2048
        }
      },
      "countParam": {
        "name": "count",
        "in": "query",
        "description": "Number of results to return. The maximum for the **count** and **offset** values together in any one query is **10,000**",
        "schema": {
          "type": "integer",
          "default": 10
        }
      },
      "offsetParam": {
        "name": "offset",
        "in": "query",
        "description": "The number of query results to skip at the beginning. For example, if the total number of results that are returned is 10 and the offset is 8, it returns the last two results. The maximum for the **count** and **offset** values together in any one query is **10000**",
        "schema": {
          "type": "integer"
        }
      },
      "docCountParam": {
        "name": "count",
        "in": "query",
        "description": "The maximum number of documents to return. Up to 1,000 documents are returned by default. The maximum number allowed is 10,000.",
        "schema": {
          "type": "integer",
          "default": 1000
        }
      }
    },
    "requestBodies": {
      "QueryLarge": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/QueryLarge"
            }
          }
        },
        "description": "An object that represents the query to be submitted."
      }
    },
    "schemas": {
      "TableElementLocation": {
        "type": "object",
        "required": [
          "begin",
          "end"
        ],
        "description": "The numeric location of the identified element in the document, represented with two integers labeled `begin` and `end`.",
        "properties": {
          "begin": {
            "description": "The element's `begin` index.",
            "type": "integer",
            "format": "int64"
          },
          "end": {
            "description": "The element's `end` index.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "QueryResponse": {
        "type": "object",
        "description": "A response that contains the documents and aggregations for the query.",
        "properties": {
          "matching_results": {
            "description": "The number of matching results for the query. Results that match due to a curation only are not counted in the total.",
            "type": "integer",
            "format": "int32"
          },
          "results": {
            "description": "Array of document results for the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryResult"
            }
          },
          "aggregations": {
            "description": "Array of aggregations for the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            },
            "minItems": 1,
            "maxItems": 50000
          },
          "retrieval_details": {
            "$ref": "#/components/schemas/RetrievalDetails"
          },
          "suggested_query": {
            "type": "string",
            "description": "Suggested correction to the submitted **natural_language_query** value."
          },
          "suggested_refinements": {
            "description": "Array of suggested refinements. **Note**: The `suggested_refinements` parameter that identified dynamic facets from the data is deprecated.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuerySuggestedRefinement"
            },
            "deprecated": true
          },
          "table_results": {
            "description": "Array of table results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QueryTableResult"
            }
          },
          "passages": {
            "type": "array",
            "description": "Passages that best match the query from across all of the collections in the project.",
            "items": {
              "$ref": "#/components/schemas/QueryResponsePassage"
            }
          }
        },
        "example": {
          "matching_results": 24,
          "retrieval_details": {
            "document_retrieval_strategy": "untrained"
          },
          "results": [
            {
              "id": "watson-generated ID"
            }
          ],
          "aggregations": [
            {
              "type": "term",
              "field": "field",
              "count": 1,
              "results": [
                {
                  "key": "active",
                  "matching_results": 34
                }
              ]
            }
          ]
        }
      },
      "QueryResult": {
        "type": "object",
        "description": "Result document for the specified query.",
        "required": [
          "document_id",
          "result_metadata"
        ],
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the document."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata of the document.",
            "additionalProperties": true
          },
          "result_metadata": {
            "$ref": "#/components/schemas/QueryResultMetadata"
          },
          "document_passages": {
            "type": "array",
            "description": "Passages from the document that best matches the query.",
            "items": {
              "$ref": "#/components/schemas/QueryResultPassage"
            }
          }
        },
        "additionalProperties": {
          "type": "object",
          "description": "The remaining key-value pairs"
        }
      },
      "QueryResultMetadata": {
        "type": "object",
        "description": "Metadata of a query result.",
        "required": [
          "collection_id"
        ],
        "properties": {
          "document_retrieval_source": {
            "type": "string",
            "enum": [
              "search",
              "curation"
            ],
            "description": "The document retrieval source that produced this search result."
          },
          "collection_id": {
            "type": "string",
            "description": "The collection id associated with this training data set."
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "description": "The confidence score for the given result. Calculated based on how relevant the result is estimated to be. confidence can range from `0.0` to `1.0`. The higher the number, the more relevant the document. The `confidence` value for a result was calculated using the model specified in the `document_retrieval_strategy` field of the result set. This field is only returned if the **natural_language_query** parameter is specified in the query."
          }
        }
      },
      "QueryResultPassage": {
        "description": "A passage query result.",
        "type": "object",
        "properties": {
          "passage_text": {
            "type": "string",
            "description": "The content of the extracted passage."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted passage in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted passage in the originating field."
          },
          "field": {
            "type": "string",
            "description": "The label of the field from which the passage has been extracted."
          },
          "confidence": {
            "type": "number",
            "description": "Estimate of the probability that the passage is relevant.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "answers": {
            "type": "array",
            "description": "An arry of extracted answers to the specified query.",
            "items": {
              "$ref": "#/components/schemas/ResultPassageAnswer"
            }
          }
        }
      },
      "QueryResponsePassage": {
        "description": "A passage query response.",
        "type": "object",
        "properties": {
          "passage_text": {
            "type": "string",
            "description": "The content of the extracted passage."
          },
          "passage_score": {
            "type": "number",
            "format": "double",
            "description": "The confidence score of the passage's analysis. A higher score indicates greater confidence. The score is used to rank the passages from all documents and is returned only if **passages.per_document** is `false`."
          },
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the ingested document."
          },
          "collection_id": {
            "type": "string",
            "description": "The unique identifier of the collection."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted passage in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted passage in the originating field."
          },
          "field": {
            "type": "string",
            "description": "The label of the field from which the passage has been extracted."
          },
          "confidence": {
            "type": "number",
            "description": "An estimate of the probability that the passage is relevant.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "answers": {
            "type": "array",
            "description": "An array of extracted answers to the specified query.",
            "items": {
              "$ref": "#/components/schemas/ResultPassageAnswer"
            }
          }
        }
      },
      "QueryTableResult": {
        "type": "object",
        "description": "A tables whose content or context match a search query.",
        "properties": {
          "table_id": {
            "type": "string",
            "description": "The identifier for the retrieved table."
          },
          "source_document_id": {
            "type": "string",
            "description": "The identifier of the document the table was retrieved from."
          },
          "collection_id": {
            "type": "string",
            "description": "The identifier of the collection the table was retrieved from."
          },
          "table_html": {
            "type": "string",
            "description": "HTML snippet of the table info."
          },
          "table_html_offset": {
            "type": "integer",
            "description": "The offset of the table html snippet in the original document html."
          },
          "table": {
            "$ref": "#/components/schemas/TableResultTable"
          }
        }
      },
      "QuerySuggestedRefinement": {
        "type": "object",
        "description": "A suggested additional query term or terms user to filter results. **Note**: The `suggested_refinements` parameter is deprecated.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The text used to filter."
          }
        },
        "deprecated": true
      },
      "QueryAggregation": {
        "type": "object",
        "description": "An abstract aggregation type produced by Discovery to analyze the input provided.",
        "required": [
          "type"
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "term": "#/components/schemas/QueryTermAggregation",
            "histogram": "#/components/schemas/QueryHistogramAggregation",
            "timeslice": "#/components/schemas/QueryTimesliceAggregation",
            "nested": "#/components/schemas/QueryNestedAggregation",
            "filter": "#/components/schemas/QueryFilterAggregation",
            "min": "#/components/schemas/QueryCalculationAggregation",
            "max": "#/components/schemas/QueryCalculationAggregation",
            "sum": "#/components/schemas/QueryCalculationAggregation",
            "average": "#/components/schemas/QueryCalculationAggregation",
            "unique_count": "#/components/schemas/QueryCalculationAggregation",
            "top_hits": "#/components/schemas/QueryTopHitsAggregation",
            "group_by": "#/components/schemas/QueryGroupByAggregation"
          }
        },
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of aggregation command used. Options include: term, histogram, timeslice, nested, filter, min, max, sum, average, unique_count, and top_hits"
          }
        }
      },
      "QueryTermAggregation": {
        "type": "object",
        "description": "Returns the top values for the field specified.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "field": {
                "type": "string",
                "description": "The field in the document used to generate top values from."
              },
              "count": {
                "type": "integer",
                "format": "int32",
                "description": "The number of top values returned"
              },
              "name": {
                "type": "string",
                "description": "Identifier specified in the query request of this aggregation."
              },
              "results": {
                "type": "array",
                "description": "Array of top values for the field",
                "items": {
                  "$ref": "#/components/schemas/QueryTermAggregationResult"
                },
                "x-apex-alternate-name": "term_results"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "QueryTermAggregationResult": {
        "type": "object",
        "description": "Top value result for the term aggregation.",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "Value of the field with a non-zero frequency in the document set."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents that contain the 'key'."
          },
          "relevancy": {
            "type": "number",
            "format": "double",
            "description": "The relevancy for this term."
          },
          "total_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "The number of documents which have the term as the value of specified field in the whole set of documents in this collection. Returned only when the `relevancy` parameter is set to `true`."
          },
          "estimated_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "The estimated number of documents which would match the query and also meet the condition. Returned only when the `relevancy` parameter is set to `true`"
          },
          "aggregations": {
            "type": "array",
            "description": "An array of sub-aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            }
          }
        }
      },
      "QueryHistogramAggregation": {
        "type": "object",
        "description": "Numeric interval segments to categorize documents by using field values from a single numeric field to describe the category.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "field": {
                "type": "string",
                "description": "The numeric field name used to create the histogram."
              },
              "interval": {
                "type": "integer",
                "format": "int32",
                "description": "The size of the sections that the results are split into.",
                "x-apex-alternate-name": "histogram_interval"
              },
              "name": {
                "type": "string",
                "description": "Identifier specified in the query request of this aggregation."
              },
              "results": {
                "type": "array",
                "description": "Array of numeric intervals",
                "items": {
                  "$ref": "#/components/schemas/QueryHistogramAggregationResult"
                },
                "x-apex-alternate-name": "histogram_results"
              }
            },
            "required": [
              "field",
              "interval"
            ]
          }
        ]
      },
      "QueryHistogramAggregationResult": {
        "type": "object",
        "description": "Histogram numeric interval result",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "integer",
            "format": "int64",
            "description": "The value of the upper bound for the numeric segment."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents with the specified key as the upper bound."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of sub-aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            }
          }
        }
      },
      "QueryTimesliceAggregation": {
        "type": "object",
        "description": "A specialized histogram aggregation that uses dates to create interval segments.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "field": {
                "type": "string",
                "description": "The date field name used to create the timeslice."
              },
              "interval": {
                "type": "string",
                "description": "The date interval value. Valid values are seconds, minutes, hours, days, weeks, and years.",
                "x-apex-alternate-name": "timeslice_interval"
              },
              "name": {
                "type": "string",
                "description": "Identifier specified in the query request of this aggregation."
              },
              "results": {
                "description": "Array of aggregation results",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/QueryTimesliceAggregationResult"
                },
                "x-apex-alternate-name": "timeslice_results"
              }
            },
            "required": [
              "field",
              "interval"
            ]
          }
        ]
      },
      "QueryTimesliceAggregationResult": {
        "type": "object",
        "description": "A timeslice interval segment.",
        "required": [
          "key_as_string",
          "key",
          "matching_results"
        ],
        "properties": {
          "key_as_string": {
            "type": "string",
            "description": "String date value of the upper bound for the timeslice interval in ISO-8601 format."
          },
          "key": {
            "type": "integer",
            "format": "int64",
            "description": "Numeric date value of the upper bound for the timeslice interval in UNIX milliseconds since epoch."
          },
          "matching_results": {
            "type": "integer",
            "format": "int64",
            "description": "Number of documents with the specified key as the upper bound."
          },
          "aggregations": {
            "type": "array",
            "description": "An array of sub-aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            }
          }
        }
      },
      "QueryNestedAggregation": {
        "type": "object",
        "description": "A restriction that alters the document set that is used for sub-aggregations it precedes to nested documents found in the field specified.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "path": {
                "type": "string",
                "description": "The path to the document field to scope sub-aggregations to."
              },
              "matching_results": {
                "type": "integer",
                "format": "int64",
                "description": "Number of nested documents found in the specified field."
              },
              "aggregations": {
                "type": "array",
                "description": "An array of sub-aggregations.",
                "items": {
                  "$ref": "#/components/schemas/QueryAggregation"
                }
              }
            },
            "required": [
              "path",
              "matching_results"
            ]
          }
        ]
      },
      "QueryFilterAggregation": {
        "type": "object",
        "description": "A modifier that narrows the document set of the sub-aggregations it precedes.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "match": {
                "type": "string",
                "description": "The filter that is written in Discovery Query Language syntax and is applied to the documents before sub-aggregations are run."
              },
              "matching_results": {
                "type": "integer",
                "format": "int64",
                "description": "Number of documents that match the filter."
              },
              "aggregations": {
                "type": "array",
                "description": "An array of sub-aggregations.",
                "items": {
                  "$ref": "#/components/schemas/QueryAggregation"
                }
              }
            },
            "required": [
              "match",
              "matching_results"
            ]
          }
        ]
      },
      "QueryCalculationAggregation": {
        "type": "object",
        "description": "Returns a scalar calculation across all documents for the field specified. Possible calculations include min, max, sum, average, and unique_count.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "field": {
                "type": "string",
                "description": "The field to perform the calculation on."
              },
              "value": {
                "description": "The value of the calculation.",
                "type": "number",
                "format": "double"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "QueryTopHitsAggregation": {
        "type": "object",
        "description": "Returns the top documents ranked by the score of the query.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "size": {
                "type": "integer",
                "format": "int32",
                "description": "The number of documents to return."
              },
              "name": {
                "type": "string",
                "description": "Identifier specified in the query request of this aggregation."
              },
              "hits": {
                "$ref": "#/components/schemas/QueryTopHitsAggregationResult"
              }
            },
            "required": [
              "size"
            ]
          }
        ]
      },
      "QueryTopHitsAggregationResult": {
        "type": "object",
        "description": "A query response that contains the matching documents for the preceding aggregations.",
        "required": [
          "matching_results"
        ],
        "properties": {
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of matching results."
          },
          "hits": {
            "type": "array",
            "description": "An array of the document results.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "TableHeaders": {
        "type": "object",
        "description": "The contents of the current table's header.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "type": "object",
            "description": "The location of the table header cell in the current table as defined by its `begin` and `end` offsets, respectfully, in the input document."
          },
          "text": {
            "type": "string",
            "description": "The textual contents of the cell from the input document without associated markup content."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableRowHeaders": {
        "type": "object",
        "description": "Row-level cells, each applicable as a header to other cells in the same row as itself, of the current table.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "text_normalized": {
            "type": "string",
            "description": "If you provide customization input, the normalized version of the cell text according to the customization; otherwise, the same value as `text`."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableKeyValuePairs": {
        "type": "object",
        "description": "Key-value pairs detected across cell boundaries.",
        "properties": {
          "key": {
            "$ref": "#/components/schemas/TableCellKey"
          },
          "value": {
            "$ref": "#/components/schemas/TableCellValue"
          }
        }
      },
      "TableCellKey": {
        "type": "object",
        "description": "A key in a key-value pair.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the key in the table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The text content of the table cell without HTML markup."
          }
        }
      },
      "TableCellValue": {
        "type": "array",
        "description": "A list of values in a key-value pair.",
        "items": {
          "$ref": "#/components/schemas/TableCellValues"
        }
      },
      "TableCellValues": {
        "type": "object",
        "description": "A value in a key-value pair.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the value in the table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The text content of the table cell without HTML markup."
          }
        }
      },
      "TableBodyCells": {
        "type": "object",
        "description": "Cells that are not table header, column header, or row header cells",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          },
          "row_header_ids": {
            "description": "A list of table row header ids",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableRowHeaderIds"
            }
          },
          "row_header_texts": {
            "description": "A list of table row header texts",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableRowHeaderTexts"
            }
          },
          "row_header_texts_normalized": {
            "description": "A list of table row header texts normalized",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableRowHeaderTextsNormalized"
            }
          },
          "column_header_ids": {
            "description": "A list of table column header ids",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableColumnHeaderIds"
            }
          },
          "column_header_texts": {
            "description": "A list of table column header texts",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableColumnHeaderTexts"
            }
          },
          "column_header_texts_normalized": {
            "description": "A list of table column header texts normalized",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableColumnHeaderTextsNormalized"
            }
          },
          "attributes": {
            "description": "A list of document attributes",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentAttribute"
            }
          }
        }
      },
      "DocumentAttribute": {
        "type": "object",
        "description": "List of document attributes",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of attribute."
          },
          "text": {
            "type": "string",
            "description": "The text associated with the attribute."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          }
        }
      },
      "TableRowHeaderIds": {
        "type": "object",
        "description": "An array of values, each being the `id` value of a row header that is applicable to this body cell.",
        "properties": {
          "id": {
            "type": "string",
            "description": "The `id` values of a row header."
          }
        }
      },
      "TableRowHeaderTexts": {
        "type": "object",
        "description": "An array of values, each being the `text` value of a row header that is applicable to this body cell.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The `text` value of a row header."
          }
        }
      },
      "TableRowHeaderTextsNormalized": {
        "type": "object",
        "description": "If you provide customization input, the normalized version of the row header texts according to the customization; otherwise, the same value as `row_header_texts`.",
        "properties": {
          "text_normalized": {
            "type": "string",
            "description": "The normalized version of a row header text."
          }
        }
      },
      "TableColumnHeaderIds": {
        "type": "object",
        "description": "An array of values, each being the `id` value of a column header that is applicable to the current cell.",
        "properties": {
          "id": {
            "type": "string",
            "description": "The `id` value of a column header."
          }
        }
      },
      "TableColumnHeaderTexts": {
        "type": "object",
        "description": "An array of values, each being the `text` value of a column header that is applicable to the current cell.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The `text` value of a column header."
          }
        }
      },
      "TableColumnHeaderTextsNormalized": {
        "type": "object",
        "description": "If you provide customization input, the normalized version of the column header texts according to the customization; otherwise, the same value as `column_header_texts`.",
        "properties": {
          "text_normalized": {
            "type": "string",
            "description": "The normalized version of a column header text."
          }
        }
      },
      "TableColumnHeaders": {
        "type": "object",
        "description": "Column-level cells, each applicable as a header to other cells in the same column as itself, of the current table.",
        "properties": {
          "cell_id": {
            "type": "string",
            "description": "The unique ID of the cell in the current table."
          },
          "location": {
            "type": "object",
            "description": "The location of the column header cell in the current table as defined by its `begin` and `end` offsets, respectfully, in the input document."
          },
          "text": {
            "type": "string",
            "description": "The textual contents of this cell from the input document without associated markup content."
          },
          "text_normalized": {
            "type": "string",
            "description": "If you provide customization input, the normalized version of the cell text according to the customization; otherwise, the same value as `text`."
          },
          "row_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `row` location in the current table."
          },
          "row_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `row` location in the current table."
          },
          "column_index_begin": {
            "type": "integer",
            "format": "int64",
            "description": "The `begin` index of this cell's `column` location in the current table."
          },
          "column_index_end": {
            "type": "integer",
            "format": "int64",
            "description": "The `end` index of this cell's `column` location in the current table."
          }
        }
      },
      "TableResultTable": {
        "type": "object",
        "description": "Full table object retrieved from Table Understanding Enrichment.",
        "properties": {
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          },
          "text": {
            "type": "string",
            "description": "The textual contents of the current table from the input document without associated markup content."
          },
          "section_title": {
            "$ref": "#/components/schemas/TableTextLocation"
          },
          "title": {
            "$ref": "#/components/schemas/TableTextLocation"
          },
          "table_headers": {
            "type": "array",
            "description": "An array of table-level cells that apply as headers to all the other cells in the current table.",
            "items": {
              "$ref": "#/components/schemas/TableHeaders"
            }
          },
          "row_headers": {
            "type": "array",
            "description": "An array of row-level cells, each applicable as a header to other cells in the same row as itself, of the current table.",
            "items": {
              "$ref": "#/components/schemas/TableRowHeaders"
            }
          },
          "column_headers": {
            "type": "array",
            "description": "An array of column-level cells, each applicable as a header to other cells in the same column as itself, of the current table.",
            "items": {
              "$ref": "#/components/schemas/TableColumnHeaders"
            }
          },
          "key_value_pairs": {
            "type": "array",
            "description": "An array of key-value pairs identified in the current table.",
            "items": {
              "$ref": "#/components/schemas/TableKeyValuePairs"
            }
          },
          "body_cells": {
            "type": "array",
            "description": "An array of cells that are neither table header nor column header nor row header cells, of the current table with corresponding row and column header associations.",
            "items": {
              "$ref": "#/components/schemas/TableBodyCells"
            }
          },
          "contexts": {
            "type": "array",
            "description": "An array of lists of textual entries across the document related to the current table being parsed.",
            "items": {
              "$ref": "#/components/schemas/TableTextLocation"
            }
          }
        }
      },
      "TableTextLocation": {
        "type": "object",
        "description": "Text and associated location within a table.",
        "properties": {
          "text": {
            "type": "string",
            "description": "The text retrieved."
          },
          "location": {
            "$ref": "#/components/schemas/TableElementLocation"
          }
        }
      },
      "ErrorResponse": {
        "type": "object",
        "description": "Error response information",
        "required": [
          "code",
          "error"
        ],
        "properties": {
          "code": {
            "description": "The HTTP error status code.",
            "type": "integer",
            "format": "int32",
            "minimum": 100,
            "maximum": 600
          },
          "error": {
            "description": "A message describing the error.",
            "type": "string"
          }
        }
      },
      "QueryLarge": {
        "type": "object",
        "description": "Object that describes a long query.",
        "properties": {
          "collection_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A comma-separated list of collection IDs to be queried against."
          },
          "filter": {
            "type": "string",
            "description": "Searches for documents that match the Discovery Query Language criteria that is specified as input. Filter calls are cached and are faster than query calls because the results are not ordered by relevance. When used with the **aggregation**, **query**, or **natural_language_query** parameters, the **filter** parameter runs first. This parameter is useful for limiting results to those that contain specific metadata values."
          },
          "query": {
            "type": "string",
            "description": "A query search that is written in the Discovery Query Language and returns all matching documents in your data set with full enrichments and full text, and with the most relevant documents listed first. Use a query search when you want to find the most relevant search results."
          },
          "natural_language_query": {
            "type": "string",
            "description": "A natural language query that returns relevant documents by using training data and natural language understanding.",
            "minLength": 1,
            "maxLength": 2048
          },
          "aggregation": {
            "type": "string",
            "description": "An aggregation search that returns an exact answer by combining query search with filters. Useful for applications to build lists, tables, and time series. For more information about the supported types of aggregations, see the [Discovery documentation](https://cloud.ibm.com/docs/discovery-data?topic=discovery-data-query-aggregations)."
          },
          "count": {
            "type": "integer",
            "description": "Number of results to return."
          },
          "return": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the fields in the document hierarchy to return. You can specify both root-level (`text`) and nested (`extracted_metadata.filename`) fields. If this parameter is an empty list, then all fields are returned.",
            "x-item-name": "return_field"
          },
          "offset": {
            "type": "integer",
            "description": "The number of query results to skip at the beginning. For example, if the total number of results that are returned is 10 and the offset is 8, it returns the last two results."
          },
          "sort": {
            "type": "string",
            "description": "A comma-separated list of fields in the document to sort on. You can optionally specify a sort direction by prefixing the field with `-` for descending or `+` for ascending. Ascending is the default sort direction if no prefix is specified."
          },
          "highlight": {
            "type": "boolean",
            "description": "When `true`, a highlight field is returned for each result that contains fields that match the query. The matching query terms are emphasized with surrounding `<em></em>` tags. This parameter is ignored if **passages.enabled** and **passages.per_document** are `true`, in which case passages are returned for each document instead of highlights."
          },
          "spelling_suggestions": {
            "type": "boolean",
            "description": "When `true` and the **natural_language_query** parameter is used, the **natural_language_query** parameter is spell checked. The most likely correction is returned in the **suggested_query** field of the response (if one exists)."
          },
          "table_results": {
            "type": "object",
            "description": "Configuration for table retrieval",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether to enable table retrieval."
              },
              "count": {
                "type": "integer",
                "description": "Maximum number of tables to return."
              }
            }
          },
          "suggested_refinements": {
            "type": "object",
            "description": "Configuration for suggested refinements.\n\n**Note**: The **suggested_refinements** parameter that identified dynamic facets from the data is deprecated.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "Whether to perform suggested refinements."
              },
              "count": {
                "type": "integer",
                "description": "Maximum number of suggested refinements texts to be returned. The maximum is `100`.",
                "maximum": 100,
                "minimum": 1
              }
            },
            "deprecated": true
          },
          "passages": {
            "type": "object",
            "description": "Configuration for passage retrieval.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "A passages query that returns the most relevant passages from the results."
              },
              "per_document": {
                "type": "boolean",
                "description": "If `true`, ranks the documents by document quality, and then returns the highest-ranked passages per document in a `document_passages` field for each document entry in the results list of the response.\n\nIf `false`, ranks the passages from all of the documents by passage quality regardless of the document quality and returns them in a separate `passages` field in the response."
              },
              "max_per_document": {
                "type": "integer",
                "description": "Maximum number of passages to return per document in the result. Ignored if **passages.per_document** is `false`."
              },
              "fields": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "A list of fields to extract passages from. If this parameter is an empty list, then all root-level fields are included."
              },
              "count": {
                "type": "integer",
                "description": "The maximum number of passages to return. Ignored if **passages.per_document** is `true`.",
                "maximum": 400
              },
              "characters": {
                "type": "integer",
                "description": "The approximate number of characters that any one passage will have.",
                "maximum": 2000,
                "minimum": 50
              },
              "find_answers": {
                "type": "boolean",
                "description": "When true, `answer` objects are returned as part of each passage in the query results. The primary difference between an `answer` and a `passage` is that the length of a passage is defined by the query, where the length of an `answer` is calculated by Discovery based on how much text is needed to answer the question.\n\nThis parameter is ignored if passages are not enabled for the query, or no **natural_language_query** is specified.\n\nIf the **find_answers** parameter is set to `true` and **per_document** parameter is also set to `true`, then the document search results and the passage search results within each document are reordered using the answer confidences. The goal of this reordering is to place the best answer as the first answer of the first passage of the first document. Similarly, if the **find_answers** parameter is set to `true` and **per_document** parameter is set to `false`, then the passage search results are reordered in decreasing order of the highest confidence answer for each document and passage.\n\nThe **find_answers** parameter is available only on managed instances of Discovery.",
                "default": false
              },
              "max_answers_per_passage": {
                "type": "integer",
                "description": "The number of `answer` objects to return per passage if the **find_answers** parmeter is specified as `true`.",
                "default": 1
              }
            }
          },
          "similar": {
            "type": "object",
            "description": "Finds results from documents that are similar to documents of interest. Use this parameter to add a *More like these* function to your search. You can include this parameter with or without a **query**, **filter** or **natural_language_query** parameter.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, includes documents in the query results that are similar to documents you specify.",
                "default": false
              },
              "document_ids": {
                "type": "array",
                "description": "The list of documents of interest. Required if **enabled** is `true`.",
                "items": {
                  "type": "string"
                }
              },
              "fields": {
                "type": "array",
                "description": "Looks for similarities in the specified subset of fields in the documents. If not specified, all of the document fields are used.",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "RetrievalDetails": {
        "type": "object",
        "description": "An object contain retrieval type information.",
        "properties": {
          "document_retrieval_strategy": {
            "type": "string",
            "description": "Identifies the document retrieval strategy used for this query. `relevancy_training` indicates that the results were returned using a relevancy trained model. \n\n**Note**: In the event of trained collections being queried, but the trained model is not used to return results, the **document_retrieval_strategy** is listed as `untrained`.",
            "enum": [
              "untrained",
              "relevancy_training"
            ]
          }
        }
      },
      "Collection": {
        "type": "object",
        "description": "A collection for storing documents.",
        "properties": {
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the collection."
          },
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the collection."
          }
        },
        "example": {
          "collection_id": "800e58e4-198d-45eb-be87-74e1d6df4e96",
          "name": "test-collection"
        }
      },
      "Completions": {
        "type": "object",
        "description": "An object that contains an array of autocompletion suggestions.",
        "properties": {
          "completions": {
            "type": "array",
            "description": "Array of autocomplete suggestion based on the provided prefix.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ComponentSettingsResponse": {
        "type": "object",
        "description": "The default component settings for this project.",
        "properties": {
          "fields_shown": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShown"
          },
          "autocomplete": {
            "type": "boolean",
            "description": "Whether or not autocomplete is enabled."
          },
          "structured_search": {
            "type": "boolean",
            "description": "Whether or not structured search is enabled."
          },
          "results_per_page": {
            "type": "integer",
            "format": "int32",
            "description": "Number or results shown per page."
          },
          "aggregations": {
            "type": "array",
            "description": "a list of component setting aggregations",
            "items": {
              "$ref": "#/components/schemas/ComponentSettingsAggregation"
            }
          }
        }
      },
      "ComponentSettingsFieldsShown": {
        "type": "object",
        "description": "Fields shown in the results section of the UI",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShownBody"
          },
          "title": {
            "$ref": "#/components/schemas/ComponentSettingsFieldsShownTitle"
          }
        }
      },
      "ComponentSettingsFieldsShownTitle": {
        "type": "object",
        "description": "Title label",
        "properties": {
          "field": {
            "type": "string",
            "description": "Use a specific field as the title."
          }
        }
      },
      "ComponentSettingsFieldsShownBody": {
        "type": "object",
        "description": "Body label",
        "properties": {
          "use_passage": {
            "type": "boolean",
            "description": "Use the whole passage as the body."
          },
          "field": {
            "type": "string",
            "description": "Use a specific field as the title."
          }
        }
      },
      "ComponentSettingsAggregation": {
        "type": "object",
        "description": "Display settings for aggregations",
        "properties": {
          "name": {
            "type": "string",
            "description": "Identifier used to map aggregation settings to aggregation configuration."
          },
          "label": {
            "type": "string",
            "description": "User-friendly alias for the aggregation"
          },
          "multiple_selections_allowed": {
            "type": "boolean",
            "description": "Whether users is allowed to select more than one of the aggregation terms."
          },
          "visualization_type": {
            "type": "string",
            "enum": [
              "auto",
              "facet_table",
              "word_cloud",
              "map"
            ],
            "description": "Type of visualization to use when rendering the aggregation."
          }
        }
      },
      "DocumentAccepted": {
        "description": "Information returned after an uploaded document is accepted.",
        "type": "object",
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the ingested document."
          },
          "status": {
            "type": "string",
            "enum": [
              "processing",
              "pending"
            ],
            "description": "Status of the document in the ingestion process. A status of `processing` is returned for documents that are ingested with a *version* date before `2019-01-01`. The `pending` status is returned for all others."
          }
        },
        "example": {
          "document_id": "f1360220-ea2d-4271-9d62-89a910b13c37",
          "status": "processing"
        }
      },
      "DeleteDocumentResponse": {
        "description": "Information returned when a document is deleted.",
        "type": "object",
        "properties": {
          "document_id": {
            "type": "string",
            "description": "The unique identifier of the document."
          },
          "status": {
            "type": "string",
            "enum": [
              "deleted"
            ],
            "description": "Status of the document. A deleted document has the status deleted."
          }
        }
      },
      "TrainingQuery": {
        "type": "object",
        "description": "Object that contains training query details.",
        "required": [
          "natural_language_query",
          "examples"
        ],
        "properties": {
          "query_id": {
            "description": "The query ID associated with the training query.",
            "type": "string",
            "readOnly": true
          },
          "natural_language_query": {
            "description": "The natural text query that is used as the training query.",
            "type": "string"
          },
          "filter": {
            "description": "The filter used on the collection before the **natural_language_query** is applied.",
            "type": "string"
          },
          "created": {
            "description": "The date and time the query was created.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "updated": {
            "description": "The date and time the query was updated.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "examples": {
            "description": "Array of training examples.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingExample"
            }
          }
        }
      },
      "TrainingExample": {
        "type": "object",
        "description": "Object that contains example response details for a training query.",
        "required": [
          "document_id",
          "collection_id",
          "relevance"
        ],
        "properties": {
          "document_id": {
            "description": "The document ID associated with this training example.",
            "type": "string"
          },
          "collection_id": {
            "description": "The collection ID associated with this training example.",
            "type": "string"
          },
          "relevance": {
            "description": "The relevance of the training example",
            "type": "integer",
            "format": "int32"
          },
          "created": {
            "description": "The date and time the example was created.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "updated": {
            "description": "The date and time the example was updated.",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "TrainingQuerySet": {
        "type": "object",
        "description": "Object specifying the training queries contained in the identified training set.",
        "properties": {
          "queries": {
            "description": "Array of training queries. At least 50 queries are required for training to begin. A maximum of 10,000 queries are returned.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrainingQuery"
            },
            "minItems": 50,
            "maxItems": 10000
          }
        }
      },
      "ListFieldsResponse": {
        "type": "object",
        "description": "The list of fetched fields.\n\nThe fields are returned using a fully qualified name format, however, the format differs slightly from that used by the query operations.\n\n  * Fields which contain nested objects are assigned a type of \"nested\".\n\n  * Fields which belong to a nested object are prefixed with `.properties` (for example, `warnings.properties.severity` means that the `warnings` object has a property called `severity`).",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            },
            "description": "An array that contains information about each field in the collections."
          }
        }
      },
      "Field": {
        "description": "Object that contains field details.",
        "type": "object",
        "properties": {
          "field": {
            "type": "string",
            "readOnly": true,
            "description": "The name of the field."
          },
          "type": {
            "type": "string",
            "enum": [
              "nested",
              "string",
              "date",
              "long",
              "integer",
              "short",
              "byte",
              "double",
              "float",
              "boolean",
              "binary"
            ],
            "readOnly": true,
            "description": "The type of the field."
          },
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The collection Id of the collection where the field was found."
          }
        }
      },
      "QueryNoticesResponse": {
        "description": "Object that contains notice query results.",
        "type": "object",
        "properties": {
          "matching_results": {
            "description": "The number of matching results",
            "type": "integer",
            "format": "int32"
          },
          "notices": {
            "description": "Array of document results that match the query.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          }
        }
      },
      "Notice": {
        "type": "object",
        "description": "A notice produced for the collection.",
        "properties": {
          "notice_id": {
            "type": "string",
            "readOnly": true,
            "description": "Identifies the notice. Many notices might have the same ID. This field exists so that user applications can programmatically identify a notice and take automatic corrective action. Typical notice IDs include:\n\n`index_failed`, `index_failed_too_many_requests`, `index_failed_incompatible_field`, `index_failed_cluster_unavailable`, `ingestion_timeout`, `ingestion_error`, `bad_request`, `internal_error`, `missing_model`, `unsupported_model`, `smart_document_understanding_failed_incompatible_field`, `smart_document_understanding_failed_internal_error`, `smart_document_understanding_failed_internal_error`, `smart_document_understanding_failed_warning`, `smart_document_understanding_page_error`, `smart_document_understanding_page_warning`. **Note:** This is not a complete list. Other values might be returned."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The creation date of the collection in the format yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
          },
          "document_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the document."
          },
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the collection."
          },
          "query_id": {
            "type": "string",
            "readOnly": true,
            "description": "Unique identifier of the query used for relevance training."
          },
          "severity": {
            "type": "string",
            "enum": [
              "warning",
              "error"
            ],
            "readOnly": true,
            "description": "Severity level of the notice."
          },
          "step": {
            "type": "string",
            "readOnly": true,
            "description": "Ingestion or training step in which the notice occurred."
          },
          "description": {
            "type": "string",
            "readOnly": true,
            "description": "The description of the notice."
          }
        }
      },
      "Curations": {
        "description": "Array of queries with curated responses for the specified project.",
        "type": "object",
        "properties": {
          "project_id": {
            "description": "The project ID of the project that contains these curations.",
            "type": "string"
          },
          "curations": {
            "description": "Array of curated queries and responses.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Curation"
            }
          }
        }
      },
      "Curation": {
        "description": "Curated query and responses.",
        "type": "object",
        "properties": {
          "curation_id": {
            "description": "The curation ID of this curation.",
            "type": "string",
            "readOnly": true
          },
          "natural_language_query": {
            "description": "The curated natural language query.",
            "type": "string"
          },
          "curated_results": {
            "description": "Array of curated results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurationResult"
            }
          }
        }
      },
      "CuratedResults": {
        "description": "Object that contains an array of curated results.",
        "type": "object",
        "properties": {
          "curated_results": {
            "description": "Array of curated results.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CurationResult"
            }
          }
        }
      },
      "CurationResult": {
        "description": "Result information for a curated query.",
        "type": "object",
        "properties": {
          "document_id": {
            "description": "The document ID of the curated result.",
            "type": "string"
          },
          "collection_id": {
            "description": "The collection ID of the curated result.",
            "type": "string"
          },
          "snippet": {
            "type": "string",
            "minLength": 0,
            "maxLength": 2000,
            "description": "Text to return in the `passage_text` field when this curated document is returned for the specified natural language query. If **passages.per_document** is `true`, the text snippet that you specify is returned as the top passage instead of the original passage that is chosen by search. Only one text snippet can be specified per document. If **passages.max_per_document** is greater than `1`, the snippet is returned first, followed by the passages that are chosen by search."
          }
        }
      },
      "CurationStatus": {
        "description": "Curation status information.",
        "type": "object",
        "properties": {
          "curation_id": {
            "description": "The curation ID of the curation.",
            "type": "string"
          },
          "status": {
            "description": "The current status of the specified curation.",
            "type": "string"
          }
        }
      },
      "CollectionDetails": {
        "type": "object",
        "description": "A collection for storing documents.",
        "required": [
          "name"
        ],
        "properties": {
          "collection_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the collection."
          },
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the collection."
          },
          "description": {
            "type": "string",
            "description": "A description of the collection."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the collection was created."
          },
          "language": {
            "type": "string",
            "description": "The language of the collection. For a list of supported languages, see the [product documentation](/docs/discovery-data?topic=discovery-data-language-support).",
            "default": "en"
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments that are applied to this collection. To get a list of enrichments that are available for a project, use the [List enrichments](#listenrichments) method.\n\nIf no enrichments are specified when the collection is created, the default enrichments for the project type are applied. For more information about project default settings, see the [product documentation](/docs/discovery-data?topic=discovery-data-project-defaults).",
            "items": {
              "$ref": "#/components/schemas/CollectionEnrichment"
            }
          },
          "smart_document_understanding": {
            "type": "object",
            "readOnly": true,
            "description": "An object that describes the Smart Document Understanding model for a collection.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, smart document understanding conversion is enabled for the collection."
              },
              "model": {
                "type": "string",
                "description": "Specifies the type of Smart Document Understanding (SDU) model that is enabled for the collection. The following types of models are supported:\n\n * `custom`: A user-trained model is applied.\n\n * `pre_trained`: A pretrained model is applied. This type of model is applied automatically to *Document Retrieval for Contracts* projects.\n\n * `text_extraction`: An SDU model that extracts text and metadata from the content. This model is enabled in collections by default regardless of the types of documents in the collection (as long as the service plan supports SDU models).\n\nYou can apply user-trained or pretrained models to collections from the *Identify fields* page of the product user interface. For more information, see [the product documentation](/docs/discovery-data?topic=discovery-data-configuring-fields).",
                "enum": [
                  "custom",
                  "pre_trained",
                  "text_extraction"
                ]
              }
            }
          }
        }
      },
      "DocumentDetails": {
        "type": "object",
        "description": "Information about a document.",
        "required": [
          "document_id"
        ],
        "properties": {
          "document_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of the document."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "Date and time that the document is added to the collection. For a child document, the date and time when the process that generates the child document runs. The date-time format is `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`."
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "Date and time that the document is finished being processed and is indexed. This date changes whenever the document is reprocessed, including for enrichment changes. The date-time format is `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'`."
          },
          "status": {
            "type": "string",
            "description": "The status of the ingestion of the document. The possible values are:\n\n* `available`: Ingestion is finished and the document is indexed.\n\n* `failed`: Ingestion is finished, but the document is not indexed because of an error.\n\n* `pending`: The document is uploaded, but the ingestion process is not started.\n\n* `processing`: Ingestion is in progress.",
            "enum": [
              "available",
              "failed",
              "pending",
              "processing"
            ]
          },
          "notices": {
            "description": "Array of JSON objects for notices, meaning warning or error messages, that are produced by the document ingestion process. The array does not include notices that are produced for child documents that are generated when a document is processed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          },
          "children": {
            "type": "object",
            "description": "Information about the child documents that are generated from a single document during ingestion or other processing.",
            "properties": {
              "have_notices": {
                "type": "boolean",
                "description": "Indicates whether the child documents have any notices. The value is `false` if the document does not have child documents."
              },
              "count": {
                "type": "integer",
                "description": "Number of child documents. The value is `0` when processing of the document doesn't generate any child documents."
              }
            }
          },
          "filename": {
            "type": "string",
            "description": "Name of the original source file (if available)."
          },
          "file_type": {
            "type": "string",
            "description": "The type of the original source file, such as `csv`, `excel`, `html`, `json`, `pdf`, `text`, `word`, and so on."
          },
          "sha256": {
            "type": "string",
            "description": "The SHA-256 hash of the original source file. The hash is formatted as a hexadecimal string."
          }
        }
      },
      "CollectionEnrichment": {
        "type": "object",
        "description": "An object describing an enrichment for a collection",
        "properties": {
          "enrichment_id": {
            "type": "string",
            "description": "The unique identifier of this enrichment. For more information about how to determine the ID of an enrichment, see [the product documentation](/docs/discovery-data?topic=discovery-data-manage-enrichments#enrichments-ids)."
          },
          "fields": {
            "type": "array",
            "description": "An array of field names that the enrichment is applied to.\n\nIf you apply an enrichment to a field from a JSON file, the data is converted to an array automatically, even if the field contains a single value.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ListProjectsResponse": {
        "type": "object",
        "description": "A list of projects in this instance.",
        "properties": {
          "projects": {
            "type": "array",
            "description": "An array of project details.",
            "items": {
              "$ref": "#/components/schemas/ProjectListDetails"
            }
          }
        }
      },
      "ProjectListDetails": {
        "type": "object",
        "description": "Details about a specific project.",
        "properties": {
          "project_id": {
            "type": "string",
            "readOnly": true,
            "description": "The unique identifier of this project."
          },
          "name": {
            "type": "string",
            "description": "The human readable name of this project."
          },
          "type": {
            "type": "string",
            "description": "The type of project.\n\nThe `content_intelligence` type is a *Document Retrieval for Contracts* project and the `other` type is a *Custom* project.\n\nThe `content_mining` and `content_intelligence` types are available with Premium plan managed deployments and installed deployments only.",
            "enum": [
              "document_retrieval",
              "conversational_search",
              "content_mining",
              "content_intelligence",
              "other"
            ]
          },
          "relevancy_training_status": {
            "type": "object",
            "readOnly": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectRelTrainStatus"
              }
            ]
          },
          "collection_count": {
            "type": "integer",
            "readOnly": true,
            "description": "The number of collections configured in this project."
          }
        }
      },
      "ProjectDetails": {
        "description": "Detailed information about the specified project.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ProjectListDetails"
          },
          {
            "type": "object",
            "description": "Extended details about a specific project.",
            "properties": {
              "default_query_parameters": {
                "$ref": "#/components/schemas/DefaultQueryParams"
              }
            }
          }
        ]
      },
      "ProjectRelTrainStatus": {
        "type": "object",
        "readOnly": true,
        "description": "Relevancy training status information for this project.",
        "properties": {
          "data_updated": {
            "type": "string",
            "description": "When the training data was updated."
          },
          "total_examples": {
            "type": "integer",
            "description": "The total number of examples."
          },
          "sufficient_label_diversity": {
            "type": "boolean",
            "description": "When `true`, sufficient label diversity is present to allow training for this project."
          },
          "processing": {
            "type": "boolean",
            "description": "When `true`, the relevancy training is in processing."
          },
          "minimum_examples_added": {
            "type": "boolean",
            "description": "When `true`, the minimum number of examples required to train has been met."
          },
          "successfully_trained": {
            "type": "string",
            "description": "The time that the most recent successful training occurred"
          },
          "available": {
            "type": "boolean",
            "description": "When `true`, relevancy training is available when querying collections in the project."
          },
          "notices": {
            "type": "integer",
            "description": "The number of notices generated during the relevancy training."
          },
          "minimum_queries_added": {
            "type": "boolean",
            "description": "When `true`, the minimum number of queries required to train has been met."
          }
        }
      },
      "Enrichments": {
        "type": "object",
        "description": "An object that contains an array of enrichment definitions.",
        "properties": {
          "enrichments": {
            "type": "array",
            "description": "An array of enrichment definitions.",
            "items": {
              "$ref": "#/components/schemas/Enrichment"
            }
          }
        }
      },
      "Enrichment": {
        "type": "object",
        "description": "Information about a specific enrichment.",
        "properties": {
          "enrichment_id": {
            "readOnly": true,
            "type": "string",
            "description": "The unique identifier of this enrichment."
          },
          "name": {
            "type": "string",
            "description": "The human readable name for this enrichment."
          },
          "description": {
            "type": "string",
            "description": "The description of this enrichment."
          },
          "type": {
            "type": "string",
            "description": "The type of this enrichment.",
            "enum": [
              "part_of_speech",
              "sentiment",
              "natural_language_understanding",
              "dictionary",
              "regular_expression",
              "uima_annotator",
              "rule_based",
              "watson_knowledge_studio_model",
              "classifier"
            ]
          },
          "options": {
            "$ref": "#/components/schemas/EnrichmentOptions"
          }
        }
      },
      "EnrichmentOptions": {
        "type": "object",
        "description": "An object that contains options for the current enrichment. Starting with version `2020-08-30`, the enrichment options are not included in responses from the List Enrichments method.",
        "properties": {
          "languages": {
            "type": "array",
            "description": "An array of supported languages for this enrichment. When creating an enrichment, only specify a language that is used by the model or in the dictionary. Required when **type** is `dictionary`. Optional when **type** is `rule_based`. Not valid when creating any other type of enrichment.",
            "items": {
              "type": "string"
            }
          },
          "entity_type": {
            "type": "string",
            "description": "The name of the entity type. This value is used as the field name in the index. Required when **type** is `dictionary` or `regular_expression`. Not valid when creating any other type of enrichment."
          },
          "regular_expression": {
            "type": "string",
            "description": "The regular expression to apply for this enrichment. Required when **type** is `regular_expression`. Not valid when creating any other type of enrichment."
          },
          "result_field": {
            "type": "string",
            "description": "The name of the result document field that this enrichment creates. Required when **type** is `rule_based` or `classifier`. Not valid when creating any other type of enrichment."
          },
          "classifier_id": {
            "type": "string",
            "description": "A unique identifier of the document classifier. Required when **type** is `classifier`. Not valid when creating any other type of enrichment."
          },
          "model_id": {
            "type": "string",
            "description": "A unique identifier of the document classifier model. Required when **type** is `classifier`. Not valid when creating any other type of enrichment."
          },
          "confidence_threshold": {
            "type": "number",
            "description": "Specifies a threshold. Only classes with evaluation confidence scores that are higher than the specified threshold are included in the output. Optional when **type** is `classifier`. Not valid when creating any other type of enrichment.",
            "format": "double",
            "default": 0,
            "minimum": 0,
            "maximum": 1
          },
          "top_k": {
            "type": "integer",
            "default": 0,
            "description": "Evaluates only the classes that fall in the top set of results when ranked by confidence. For example, if set to `5`, then the top five classes for each document are evaluated. If set to 0, the **confidence_threshold** is used to determine the predicted classes. Optional when **type** is `classifier`. Not valid when creating any other type of enrichment."
          }
        },
        "x-ibm-change-notices": [
          {
            "version": "2020-08-30",
            "type": "update",
            "description": "The enrichment options are not included in responses from the [List enrichments](#listenrichments) method. They continue to be returned with the [Get enrichment](#getenrichment) method."
          }
        ]
      },
      "UpdateEnrichment": {
        "type": "object",
        "description": "An object that contains a new name and description for an enrichment.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the enrichment."
          },
          "description": {
            "type": "string",
            "description": "A new description for the enrichment."
          }
        }
      },
      "AnalyzedDocument": {
        "type": "object",
        "description": "An object that contains the converted document and any identified enrichments. Root-level fields from the original file are returned also.",
        "properties": {
          "notices": {
            "description": "Array of notices that are triggered when the files are processed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Notice"
            }
          },
          "result": {
            "$ref": "#/components/schemas/AnalyzedResult"
          }
        }
      },
      "AnalyzedResult": {
        "type": "object",
        "description": "Result of the document analysis.",
        "properties": {
          "metadata": {
            "type": "object",
            "description": "Metadata that was specified with the request.",
            "additionalProperties": true
          }
        },
        "additionalProperties": {
          "type": "object",
          "description": "The remaining key-value pairs"
        }
      },
      "QueryGroupByAggregation": {
        "type": "object",
        "description": "Returns the top values for the field specified.",
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryAggregation"
          },
          {
            "properties": {
              "results": {
                "type": "array",
                "description": "Array of top values for the field",
                "items": {
                  "$ref": "#/components/schemas/QueryGroupByAggregationResult"
                },
                "x-apex-alternate-name": "groupby_results"
              }
            }
          }
        ]
      },
      "QueryGroupByAggregationResult": {
        "type": "object",
        "description": "Top value result for the term aggregation.",
        "required": [
          "key",
          "matching_results"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "Value of the field with a non-zero frequency in the document set."
          },
          "matching_results": {
            "type": "integer",
            "format": "int32",
            "description": "Number of documents that contain the 'key'."
          },
          "relevancy": {
            "type": "number",
            "format": "double",
            "description": "The relevancy for this group."
          },
          "total_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "The number of documents which have the group as the value of specified field in the whole set of documents in this collection. Returned only when the `relevancy` parameter is set to `true`."
          },
          "estimated_matching_documents": {
            "type": "integer",
            "format": "int32",
            "description": "The estimated number of documents which would match the query and also meet the condition. Returned only when the `relevancy` parameter is set to `true`"
          },
          "aggregations": {
            "type": "array",
            "description": "An array of sub-aggregations.",
            "items": {
              "$ref": "#/components/schemas/QueryAggregation"
            }
          }
        }
      },
      "DefaultQueryParams": {
        "type": "object",
        "description": "Default query parameters for this project.",
        "properties": {
          "collection_ids": {
            "type": "array",
            "description": "An array of collection identifiers to query. If empty or omitted all collections in the project are queried.",
            "items": {
              "type": "string"
            }
          },
          "passages": {
            "type": "object",
            "description": "Default settings configuration for passage search options.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, a passage search is performed by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of passages to return."
              },
              "fields": {
                "type": "array",
                "description": "An array of field names to perform the passage search on.",
                "items": {
                  "type": "string"
                }
              },
              "characters": {
                "type": "integer",
                "description": "The approximate number of characters that each returned passage will contain."
              },
              "per_document": {
                "type": "boolean",
                "description": "When `true` the number of passages that can be returned from a single document is restricted to the *max_per_document* value."
              },
              "max_per_document": {
                "type": "integer",
                "description": "The default maximum number of passages that can be taken from a single document as the result of a passage query."
              }
            }
          },
          "table_results": {
            "type": "object",
            "description": "Default project query settings for table results.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, a table results for the query are returned by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of table results to return by default."
              },
              "per_document": {
                "type": "integer",
                "default": 0,
                "description": "The number of table results to include in each result document."
              }
            }
          },
          "aggregation": {
            "type": "string",
            "description": "A string representing the default aggregation query for the project."
          },
          "suggested_refinements": {
            "type": "object",
            "description": "Object that contains suggested refinement settings.\n\n**Note**: The `suggested_refinements` parameter that identified dynamic facets from the data is deprecated.",
            "properties": {
              "enabled": {
                "type": "boolean",
                "description": "When `true`, suggested refinements for the query are returned by default."
              },
              "count": {
                "type": "integer",
                "description": "The number of suggested refinements to return by default."
              }
            },
            "deprecated": true
          },
          "spelling_suggestions": {
            "type": "boolean",
            "description": "When `true`, a spelling suggestions for the query are returned by default."
          },
          "highlight": {
            "type": "boolean",
            "description": "When `true`, highlights for the query are returned by default."
          },
          "count": {
            "type": "integer",
            "description": "The number of document results returned by default."
          },
          "sort": {
            "type": "string",
            "description": "A comma separated list of document fields to sort results by default."
          },
          "return": {
            "type": "array",
            "description": "An array of field names to return in document results if present by default.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ProjectName": {
        "type": "object",
        "description": "Object that contains a new name for the specified project.",
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name to give this project."
          }
        }
      },
      "ProjectCreationDetails": {
        "type": "object",
        "description": "Details about a specific project.",
        "required": [
          "name",
          "type"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The human readable name of this project."
          },
          "type": {
            "type": "string",
            "description": "The type of project.\n\nThe `content_intelligence` type is a *Document Retrieval for Contracts* project and the `other` type is a *Custom* project.\n\nThe `content_mining` and `content_intelligence` types are available with Premium plan managed deployments and installed deployments only.",
            "enum": [
              "document_retrieval",
              "conversational_search",
              "content_intelligence",
              "content_mining",
              "other"
            ]
          }
        }
      },
      "ProjectCreation": {
        "description": "Detailed information about the specified project.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ProjectCreationDetails"
          },
          {
            "type": "object",
            "description": "Extended details about a specific project.",
            "properties": {
              "default_query_parameters": {
                "$ref": "#/components/schemas/DefaultQueryParams"
              }
            }
          }
        ]
      },
      "UpdateCollection": {
        "type": "object",
        "description": "An object that represents the collection to be updated.",
        "properties": {
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The new name of the collection."
          },
          "description": {
            "type": "string",
            "description": "The new description of the collection."
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments that are applied to this collection.",
            "items": {
              "$ref": "#/components/schemas/CollectionEnrichment"
            }
          }
        }
      },
      "CreateEnrichment": {
        "type": "object",
        "description": "Information about a specific enrichment.",
        "properties": {
          "name": {
            "type": "string",
            "description": "The human readable name for this enrichment."
          },
          "description": {
            "type": "string",
            "description": "The description of this enrichment."
          },
          "type": {
            "type": "string",
            "description": "The type of this enrichment. The following types are supported:\n\n* `classifier`: Creates a document classifier enrichment from a document classifier model that you create by using the [Document classifier API](/apidocs/discovery-data#createdocumentclassifier). **Note**: A text classifier enrichment can be created only from the product user interface.\n\n* `dictionary`: Creates a custom dictionary enrichment that you define in a CSV file.\n\n* `regular_expression`: Creates a custom regular expression enrichment from regex syntax that you specify in the request.\n\n* `rule_based`: Creates an enrichment from an advanced rules model that is created and exported as a ZIP file from Watson Knowledge Studio.\n\n* `uima_annotator`: Creates an enrichment from a custom UIMA text analysis model that is defined in a PEAR file created in one of the following ways:\n\n    * Watson Explorer Content Analytics Studio. **Note**: Supported in IBM Cloud Pak for Data instances only.\n\n    * Rule-based model that is created in Watson Knowledge Studio.\n\n* `watson_knowledge_studio_model`: Creates an enrichment from a Watson Knowledge Studio machine learning model that is defined in a ZIP file.",
            "enum": [
              "classifier",
              "dictionary",
              "regular_expression",
              "uima_annotator",
              "rule_based",
              "watson_knowledge_studio_model"
            ]
          },
          "options": {
            "$ref": "#/components/schemas/EnrichmentOptions"
          }
        }
      },
      "ResultPassageAnswer": {
        "type": "object",
        "description": "Object that contains a potential answer to the specified query.",
        "properties": {
          "answer_text": {
            "type": "string",
            "description": "Answer text for the specified query as identified by Discovery."
          },
          "start_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position of the first character of the extracted answer in the originating field."
          },
          "end_offset": {
            "type": "integer",
            "format": "int32",
            "description": "The position after the last character of the extracted answer in the originating field."
          },
          "confidence": {
            "type": "number",
            "description": "An estimate of the probability that the answer is relevant.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "DocumentClassifiers": {
        "type": "object",
        "description": "An object that contains a list of document classifier definitions.",
        "properties": {
          "classifiers": {
            "type": "array",
            "description": "An array of document classifier definitions.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifier"
            }
          }
        }
      },
      "DocumentClassifier": {
        "type": "object",
        "description": "Information about a document classifier.",
        "required": [
          "classifier_id",
          "name"
        ],
        "properties": {
          "classifier_id": {
            "readOnly": true,
            "type": "string",
            "description": "A unique identifier of the document classifier."
          },
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier was created."
          },
          "language": {
            "type": "string",
            "description": "The language of the training data that is associated with the document classifier. Language is specified by using the ISO 639-1 language code, such as `en` for English or `ja` for Japanese.",
            "default": "en"
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments to apply to the data that is used to train and test the document classifier. The output from the enrichments is used as features by the classifier to classify the document content both during training and at run time.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierEnrichment"
            }
          },
          "recognized_fields": {
            "type": "array",
            "description": "An array of fields that are used to train the document classifier. The same set of fields must exist in the training data, the test data, and the documents where the resulting document classifier enrichment is applied at run time.",
            "items": {
              "type": "string"
            }
          },
          "answer_field": {
            "type": "string",
            "description": "The name of the field from the training and test data that contains the classification labels."
          },
          "training_data_file": {
            "type": "string",
            "description": "Name of the CSV file with training data that is used to train the document classifier."
          },
          "test_data_file": {
            "type": "string",
            "description": "Name of the CSV file with data that is used to test the document classifier. If no test data is provided, a subset of the training data is used for testing purposes."
          },
          "federated_classification": {
            "$ref": "#/components/schemas/ClassifierFederatedModel"
          }
        }
      },
      "DocumentClassifierEnrichment": {
        "type": "object",
        "description": "An object that describes enrichments that are applied to the training and test data that is used by the document classifier.",
        "required": [
          "enrichment_id",
          "fields"
        ],
        "properties": {
          "enrichment_id": {
            "type": "string",
            "description": "A unique identifier of the enrichment."
          },
          "fields": {
            "type": "array",
            "description": "An array of field names where the enrichment is applied.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ClassifierFederatedModel": {
        "type": "object",
        "description": "An object with details for creating federated document classifier models.",
        "required": [
          "field"
        ],
        "properties": {
          "field": {
            "type": "string",
            "description": "Name of the field that contains the values from which multiple classifier models are defined. For example, you can specify a field that lists product lines to create a separate model per product line."
          }
        }
      },
      "CreateDocumentClassifier": {
        "type": "object",
        "description": "An object that manages the settings and data that is required to train a document classification model.",
        "required": [
          "name",
          "language",
          "answer_field"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier."
          },
          "language": {
            "type": "string",
            "description": "The language of the training data that is associated with the document classifier. Language is specified by using the ISO 639-1 language code, such as `en` for English or `ja` for Japanese.",
            "default": "en"
          },
          "answer_field": {
            "type": "string",
            "description": "The name of the field from the training and test data that contains the classification labels."
          },
          "enrichments": {
            "type": "array",
            "description": "An array of enrichments to apply to the data that is used to train and test the document classifier. The output from the enrichments is used as features by the classifier to classify the document content both during training and at run time.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierEnrichment"
            }
          },
          "federated_classification": {
            "$ref": "#/components/schemas/ClassifierFederatedModel"
          }
        }
      },
      "UpdateDocumentClassifier": {
        "type": "object",
        "description": "An object that contains a new name or description for a document classifier, updated training data, or new or updated test data.",
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the classifier.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A new description for the classifier."
          }
        }
      },
      "DocumentClassifierModels": {
        "type": "object",
        "description": "An object that contains a list of document classifier model definitions.",
        "properties": {
          "models": {
            "type": "array",
            "description": "An array of document classifier model definitions.",
            "items": {
              "$ref": "#/components/schemas/DocumentClassifierModel"
            }
          }
        }
      },
      "DocumentClassifierModel": {
        "type": "object",
        "description": "Information about a document classifier model.",
        "required": [
          "model_id",
          "name"
        ],
        "properties": {
          "model_id": {
            "readOnly": true,
            "type": "string",
            "description": "A unique identifier of the document classifier model."
          },
          "name": {
            "type": "string",
            "description": "A human-readable name of the document classifier model.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier model."
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was created."
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was last updated."
          },
          "training_data_file": {
            "type": "string",
            "description": "Name of the CSV file that contains the training data that is used to train the document classifier model."
          },
          "test_data_file": {
            "type": "string",
            "description": "Name of the CSV file that contains data that is used to test the document classifier model. If no test data is provided, a subset of the training data is used for testing purposes."
          },
          "status": {
            "type": "string",
            "enum": [
              "training",
              "available",
              "failed"
            ],
            "description": "The status of the training run."
          },
          "evaluation": {
            "$ref": "#/components/schemas/ClassifierModelEvaluation"
          },
          "enrichment_id": {
            "type": "string",
            "description": "A unique identifier of the enrichment that is generated by this document classifier model."
          },
          "deployed_at": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The date that the document classifier model was deployed."
          }
        }
      },
      "ClassifierModelEvaluation": {
        "type": "object",
        "description": "An object that contains information about a trained document classifier model.",
        "required": [
          "micro_average",
          "macro_average",
          "per_class"
        ],
        "properties": {
          "micro_average": {
            "$ref": "#/components/schemas/ModelEvaluationMicroAverage"
          },
          "macro_average": {
            "$ref": "#/components/schemas/ModelEvaluationMacroAverage"
          },
          "per_class": {
            "type": "array",
            "description": "An array of evaluation metrics, one set of metrics for each class, where class refers to the classification label that is specified in the **answer_field**.",
            "items": {
              "$ref": "#/components/schemas/PerClassModelEvaluation"
            }
          }
        }
      },
      "ModelEvaluationMacroAverage": {
        "type": "object",
        "description": "A macro-average computes metric independently for each class and then takes the average. Class refers to the classification label that is specified in the **answer_field**.",
        "required": [
          "precision",
          "recall",
          "f1"
        ],
        "properties": {
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "ModelEvaluationMicroAverage": {
        "type": "object",
        "required": [
          "precision",
          "recall",
          "f1"
        ],
        "description": "A micro-average aggregates the contributions of all classes to compute the average metric. Classes refers to the classification labels that are specified in the **answer_field**.",
        "properties": {
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "PerClassModelEvaluation": {
        "type": "object",
        "description": "An object that measures the metrics from a training run for each classification label separately.",
        "required": [
          "name",
          "precision",
          "recall",
          "f1"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Class name. Each class name is derived from a value in the **answer_field**."
          },
          "precision": {
            "type": "number",
            "description": "A metric that measures how many of the overall documents are classified correctly.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "A metric that measures how often documents that should be classified into certain classes are classified into those classes.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          },
          "f1": {
            "type": "number",
            "description": "A metric that measures whether the optimal balance between precision and recall is reached. The F1 score can be interpreted as a weighted average of the precision and recall values. An F1 score reaches its best value at 1 and worst value at 0.",
            "format": "double",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "DocumentClassifierModelTrain": {
        "type": "object",
        "description": "An object that contains configuration settings for a document classifier model training run.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 0,
            "maxLength": 255,
            "description": "The name of the document classifier model."
          },
          "description": {
            "type": "string",
            "description": "A description of the document classifier model."
          },
          "learning_rate": {
            "type": "number",
            "description": "A tuning parameter in an optimization algorithm that determines the step size at each iteration of the training process. It influences how much of any newly acquired information overrides the existing information, and therefore is said to represent the speed at which a machine learning model learns. The default value is `0.1`.",
            "format": "double",
            "default": 0.1,
            "minimum": 0,
            "maximum": 1
          },
          "l1_regularization_strengths": {
            "type": "array",
            "description": "Avoids overfitting by shrinking the coefficient of less important features to zero, which removes some features altogether. You can specify many values for hyper-parameter optimization. The default value is `[0.000001]`.",
            "items": {
              "type": "number",
              "format": "double",
              "minimum": 0
            },
            "default": [
              0.000001
            ]
          },
          "l2_regularization_strengths": {
            "type": "array",
            "description": "A method you can apply to avoid overfitting your model on the training data. You can specify many values for hyper-parameter optimization. The default value is `[0.000001]`.",
            "items": {
              "type": "number",
              "format": "double",
              "minimum": 0
            },
            "default": [
              0.000001
            ]
          },
          "training_max_steps": {
            "description": "Maximum number of training steps to complete. This setting is useful if you need the training process to finish in a specific time frame to fit into an automated process. The default value is ten million.",
            "type": "integer",
            "default": 10000000,
            "minimum": 0
          },
          "improvement_ratio": {
            "type": "number",
            "description": "Stops the training run early if the improvement ratio is not met by the time the process reaches a certain point. The default value is `0.00001`.",
            "format": "double",
            "default": 0.00001,
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "UpdateDocumentClassifierModel": {
        "type": "object",
        "description": "An object that contains a new name or description for a document classifier model.",
        "properties": {
          "name": {
            "type": "string",
            "description": "A new name for the enrichment.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "A new description for the enrichment."
          }
        }
      },
      "StopWordList": {
        "type": "object",
        "required": [
          "stopwords"
        ],
        "description": "List of words to filter out of text that is submitted in queries.",
        "properties": {
          "stopwords": {
            "description": "List of stop words.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Expansions": {
        "type": "object",
        "required": [
          "expansions"
        ],
        "description": "The query expansion definitions for the specified collection.",
        "properties": {
          "expansions": {
            "type": "array",
            "description": "An array of query expansion definitions. \n\n Each object in the **expansions** array represents a term or set of terms that will be expanded into other terms. Each expansion object can be configured as `bidirectional` or `unidirectional`. \n\n* **Bidirectional**: Each entry in the `expanded_terms` list expands to include all expanded terms. For example, a query for `ibm` expands to `ibm OR international business machines OR big blue`.\n\n* **Unidirectional**: The terms in `input_terms` in the query are replaced by the terms in `expanded_terms`. For example, a query for the often misused term `on premise` is converted to `on premises OR on-premises` and does not contain the original term. If you want an input term to be included in the query, then repeat the input term in the expanded terms list.",
            "items": {
              "$ref": "#/components/schemas/Expansion"
            },
            "minItems": 0,
            "maxItems": 5000
          }
        }
      },
      "Expansion": {
        "type": "object",
        "required": [
          "expanded_terms"
        ],
        "description": "An expansion definition. Each object respresents one set of expandable strings. For example, you could have expansions for the word `hot` in one object, and expansions for the word `cold` in another. Follow these guidelines when you add terms:\n\n* Specify the terms in lowercase. Lowercase terms expand to uppercase.\n\n* Multiword terms are supported only in bidirectional expansions.\n\n* Do not specify a term that is specified in the stop words list for the collection.",
        "properties": {
          "input_terms": {
            "type": "array",
            "description": "A list of terms that will be expanded for this expansion. If specified, only the items in this list are expanded.",
            "items": {
              "type": "string"
            }
          },
          "expanded_terms": {
            "type": "array",
            "description": "A list of terms that this expansion will be expanded to. If specified without **input_terms**, the list also functions as the input term list.",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  }
}
